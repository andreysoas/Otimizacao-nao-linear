# -*- coding: utf-8 -*-
"""Gradiente por Método de Newton.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1STldYrMXufRdSygP5op_-4A2AZXMkbux

Obter o novo ponto e sempre ter o ponto anterior para obtenção de Pk e Qk
"""

import numpy as np
from sympy import *
from sympy import Lambda
x,y,z,f,a = symbols('x y z f a')
import math
init_printing(use_unicode=True)
e = math.e

def methodNewt2(funcaoStr:str,x_0:list,EPSILON:float):
  variablesList = [x,y]
  NULLVECTOR = [0,0]
  numVar = len(x_0)

  if numVar == 3:
    variablesList.append(z)
    NULLVECTOR.append(0)

  variablesList = tuple(variablesList)
  funcao = Lambda(variablesList,funcaoStr)
  listaDerivadas = []
  
  for i in variablesList:
    f = Lambda(variablesList , diff(funcaoStr,i ))
    listaDerivadas.append(f)

  while true:
    #print('pontos: ',x_0)
    error=0

    gradient = []
    
    for i in listaDerivadas:
      if numVar == 2:
        gradient.append(i(x_0[0],x_0[1]))
      else:
        gradient.append(i(x_0[0],x_0[1],x_0[2]))

    for i in gradient:
      error += i**2
  
    if (gradient != NULLVECTOR) and (error > EPSILON) : #x0 não era ótimo ou não atende ao erro

      x1 = '('+str(x_0[0]+(a*-1*(gradient[0])))+')' #pegando os novos x e y como string
      y1 = '('+str(x_0[1]+(a*-1*(gradient[1])))+')'

      x1_vetor = Lambda(a,x1)   # função de alfa do vetor
      y1_vetor = Lambda(a,y1)   #função de alfa do vetor
      if numVar == 3:
        z1 = '('+str(x_0[2]+(a*-1*(gradient[2])))+')'
        z1_vetor = Lambda(a,z1)


      gFunction = funcaoStr
      gFunction = gFunction.replace('x',x1)
      gFunction = gFunction.replace('y',y1)
      if numVar == 3:
        gFunction = gFunction.replace('z',z1)
  
      alfa = Newton_method(gFunction,0)
    
      x_0[0] = x1_vetor(alfa)
      x_0[1] = y1_vetor(alfa)
      if numVar == 3:
        x_0[2] = z1_vetor(alfa)

    else:
      funcVal = 0
      if numVar == 2:
        funcVal = funcao(x_0[0],x_0[1])
      else:
        funcVal = funcao(x_0[0],x_0[1],x_0[2])

      print('Gradiente: ',gradient)
      print('Ponto encontrado: ',x_0,' | Valor de função: ',funcVal)
      break

def derivates(funcao,alfa_0):
  funcao_dif1 = diff(funcao(a),a) # Diferencia a função uma vez
  f_1 = Lambda(a,funcao_dif1)     # Cria uma função lambda com o objeto

  funcao_dif2 = diff(funcao(a),a,2)  #Diferencia a função duas vezes 
  f_2 = Lambda(a,funcao_dif2)        #cria uma função lambda com o objeto

  return iteration_method(funcao,f_1,f_2,alfa_0)

def iteration_method(funcao,f_1,f_2,alfa_0):
  EPSILON = 0.00001
  alfa_ant = alfa_0 + 1
  while true:
    
    alfa_ant = alfa_0
    alfa_0 = float(alfa_0 - (f_1(alfa_0)/f_2(alfa_0)))
    
    if f_1(alfa_0)==0 and f_2(alfa_0)>0:
      return alfa_0
    
    elif (math.fabs(f_1(alfa_0)) < EPSILON) and (f_2(alfa_0) > 0):
      return alfa_0

def Newton_method(funcao,alfa_0):
  return derivates(Lambda(a,funcao),alfa_0)

def programInterface():
  
  pInicial=[]
  numVar = 2

  funcao = str(input('Defina a função desejada("end" para terminar): '))
  if funcao == 'end':
    return true

  if 'z' in funcao:
    numVar=3

  for i in range(numVar):
    x = float(input('Coordenada do ponto(uma coordenada por vez): '))
    pInicial.append(x)

  EPSILON = float(input('Erro(ex.: 0.001 , 0.0001 , ...): '))
  
  methodNewt2(funcao,pInicial,EPSILON)
  print('\n')

while true:
  if programInterface():
    break